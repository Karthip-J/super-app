{"ast":null,"code":"import { api, URBAN_SERVICES_URL } from '../utils/api';\nimport { webSocketService } from './websocket';\nexport const partnerService = {\n  // Get available bookings for partners\n  getAvailableBookings: async (params = {}) => {\n    try {\n      var _response$data;\n      const response = await api.get(`${URBAN_SERVICES_URL}/bookings/available`, {\n        params: {\n          status: 'pending',\n          limit: 50,\n          ...params\n        }\n      });\n      return ((_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.data) || response.data || [];\n    } catch (error) {\n      console.error('Error fetching available bookings:', error);\n      throw error;\n    }\n  },\n  // Get partner's bookings\n  getBookings: async (status = '', params = {}) => {\n    try {\n      var _response$data2;\n      const response = await api.get(`${URBAN_SERVICES_URL}/partner/bookings`, {\n        params: {\n          status,\n          limit: 100,\n          ...params\n        }\n      });\n      return ((_response$data2 = response.data) === null || _response$data2 === void 0 ? void 0 : _response$data2.data) || response.data || [];\n    } catch (error) {\n      console.error('Error fetching bookings:', error);\n      throw error;\n    }\n  },\n  // Update booking status\n  updateBookingStatus: async (bookingId, status, reason = '') => {\n    try {\n      const response = await api.put(`${URBAN_SERVICES_URL}/bookings/${bookingId}/status`, {\n        status,\n        ...(reason && {\n          reason\n        })\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error updating booking status:', error);\n      throw error;\n    }\n  },\n  // Get partner profile\n  getProfile: async () => {\n    try {\n      var _response$data3;\n      const response = await api.get(`${URBAN_SERVICES_URL}/partners/profile`);\n      return ((_response$data3 = response.data) === null || _response$data3 === void 0 ? void 0 : _response$data3.data) || response.data || {};\n    } catch (error) {\n      console.error('Error fetching partner profile:', error);\n      throw error;\n    }\n  },\n  // Get partner stats\n  getStats: async () => {\n    try {\n      const [bookings, profile] = await Promise.all([partnerService.getBookings('completed,in-progress,pending'), partnerService.getProfile().catch(() => ({})) // Don't fail if profile fails\n      ]);\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      const todayEarnings = bookings.filter(booking => booking.status === 'completed' && new Date(booking.updatedAt || booking.createdAt) >= today).reduce((sum, booking) => {\n        var _booking$pricing;\n        return sum + (((_booking$pricing = booking.pricing) === null || _booking$pricing === void 0 ? void 0 : _booking$pricing.totalAmount) || booking.amount || 0);\n      }, 0);\n      const totalEarnings = bookings.filter(booking => booking.status === 'completed').reduce((sum, booking) => {\n        var _booking$pricing2;\n        return sum + (((_booking$pricing2 = booking.pricing) === null || _booking$pricing2 === void 0 ? void 0 : _booking$pricing2.totalAmount) || booking.amount || 0);\n      }, 0);\n      const pendingBookings = bookings.filter(b => b.status === 'pending').length;\n      const completedBookings = bookings.filter(b => b.status === 'completed').length;\n      return {\n        totalBookings: bookings.length,\n        completedBookings,\n        pendingBookings,\n        todayEarnings,\n        totalEarnings,\n        averageRating: profile.rating || 0\n      };\n    } catch (error) {\n      console.error('Error calculating stats:', error);\n      return {\n        totalBookings: 0,\n        completedBookings: 0,\n        pendingBookings: 0,\n        todayEarnings: 0,\n        totalEarnings: 0,\n        averageRating: 0\n      };\n    }\n  },\n  // WebSocket methods\n  subscribeToBookings: callback => {\n    // Initial fetch\n    const fetchData = async () => {\n      try {\n        const [available, accepted] = await Promise.all([partnerService.getAvailableBookings(), partnerService.getBookings('accepted,in-progress')]);\n        callback({\n          type: 'INITIAL_DATA',\n          available,\n          accepted\n        });\n      } catch (error) {\n        console.error('Error fetching initial data:', error);\n      }\n    };\n    fetchData();\n\n    // Subscribe to real-time updates\n    const handleMessage = message => {\n      switch (message.type) {\n        case 'NEW_BOOKING':\n          callback({\n            type: 'NEW_BOOKING',\n            booking: message.data\n          });\n          break;\n        case 'BOOKING_UPDATED':\n          callback({\n            type: 'BOOKING_UPDATED',\n            booking: message.data\n          });\n          break;\n        case 'BOOKING_CANCELLED':\n          callback({\n            type: 'BOOKING_CANCELLED',\n            bookingId: message.bookingId\n          });\n          break;\n      }\n    };\n\n    // Connect to WebSocket if not already connected\n    webSocketService.connect();\n    const unsubscribe = webSocketService.subscribe(handleMessage);\n\n    // Return cleanup function\n    return () => {\n      unsubscribe();\n      // Don't disconnect WebSocket here as it might be used by other components\n    };\n  }\n};\nexport default partnerService;","map":{"version":3,"names":["api","URBAN_SERVICES_URL","webSocketService","partnerService","getAvailableBookings","params","_response$data","response","get","status","limit","data","error","console","getBookings","_response$data2","updateBookingStatus","bookingId","reason","put","getProfile","_response$data3","getStats","bookings","profile","Promise","all","catch","today","Date","setHours","todayEarnings","filter","booking","updatedAt","createdAt","reduce","sum","_booking$pricing","pricing","totalAmount","amount","totalEarnings","_booking$pricing2","pendingBookings","b","length","completedBookings","totalBookings","averageRating","rating","subscribeToBookings","callback","fetchData","available","accepted","type","handleMessage","message","connect","unsubscribe","subscribe"],"sources":["D:/SUPER APP MAIN NEW/SUPER APP MAIN NEW/super_app-main/urban-partner-app/src/services/partnerService.js"],"sourcesContent":["import { api, URBAN_SERVICES_URL } from '../utils/api';\r\nimport { webSocketService } from './websocket';\r\n\r\nexport const partnerService = {\r\n  // Get available bookings for partners\r\n  getAvailableBookings: async (params = {}) => {\r\n    try {\r\n      const response = await api.get(`${URBAN_SERVICES_URL}/bookings/available`, {\r\n        params: {\r\n          status: 'pending',\r\n          limit: 50,\r\n          ...params\r\n        }\r\n      });\r\n      return response.data?.data || response.data || [];\r\n    } catch (error) {\r\n      console.error('Error fetching available bookings:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get partner's bookings\r\n  getBookings: async (status = '', params = {}) => {\r\n    try {\r\n      const response = await api.get(`${URBAN_SERVICES_URL}/partner/bookings`, {\r\n        params: {\r\n          status,\r\n          limit: 100,\r\n          ...params\r\n        }\r\n      });\r\n      return response.data?.data || response.data || [];\r\n    } catch (error) {\r\n      console.error('Error fetching bookings:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Update booking status\r\n  updateBookingStatus: async (bookingId, status, reason = '') => {\r\n    try {\r\n      const response = await api.put(\r\n        `${URBAN_SERVICES_URL}/bookings/${bookingId}/status`,\r\n        { status, ...(reason && { reason }) }\r\n      );\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error updating booking status:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get partner profile\r\n  getProfile: async () => {\r\n    try {\r\n      const response = await api.get(`${URBAN_SERVICES_URL}/partners/profile`);\r\n      return response.data?.data || response.data || {};\r\n    } catch (error) {\r\n      console.error('Error fetching partner profile:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get partner stats\r\n  getStats: async () => {\r\n    try {\r\n      const [bookings, profile] = await Promise.all([\r\n        partnerService.getBookings('completed,in-progress,pending'),\r\n        partnerService.getProfile().catch(() => ({})) // Don't fail if profile fails\r\n      ]);\r\n\r\n      const today = new Date();\r\n      today.setHours(0, 0, 0, 0);\r\n\r\n      const todayEarnings = bookings\r\n        .filter(booking => \r\n          booking.status === 'completed' && \r\n          new Date(booking.updatedAt || booking.createdAt) >= today\r\n        )\r\n        .reduce((sum, booking) => sum + (booking.pricing?.totalAmount || booking.amount || 0), 0);\r\n\r\n      const totalEarnings = bookings\r\n        .filter(booking => booking.status === 'completed')\r\n        .reduce((sum, booking) => sum + (booking.pricing?.totalAmount || booking.amount || 0), 0);\r\n\r\n      const pendingBookings = bookings.filter(b => b.status === 'pending').length;\r\n      const completedBookings = bookings.filter(b => b.status === 'completed').length;\r\n\r\n      return {\r\n        totalBookings: bookings.length,\r\n        completedBookings,\r\n        pendingBookings,\r\n        todayEarnings,\r\n        totalEarnings,\r\n        averageRating: profile.rating || 0\r\n      };\r\n    } catch (error) {\r\n      console.error('Error calculating stats:', error);\r\n      return {\r\n        totalBookings: 0,\r\n        completedBookings: 0,\r\n        pendingBookings: 0,\r\n        todayEarnings: 0,\r\n        totalEarnings: 0,\r\n        averageRating: 0\r\n      };\r\n    }\r\n  },\r\n\r\n  // WebSocket methods\r\n  subscribeToBookings: (callback) => {\r\n    // Initial fetch\r\n    const fetchData = async () => {\r\n      try {\r\n        const [available, accepted] = await Promise.all([\r\n          partnerService.getAvailableBookings(),\r\n          partnerService.getBookings('accepted,in-progress')\r\n        ]);\r\n        callback({ type: 'INITIAL_DATA', available, accepted });\r\n      } catch (error) {\r\n        console.error('Error fetching initial data:', error);\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n\r\n    // Subscribe to real-time updates\r\n    const handleMessage = (message) => {\r\n      switch (message.type) {\r\n        case 'NEW_BOOKING':\r\n          callback({ type: 'NEW_BOOKING', booking: message.data });\r\n          break;\r\n        case 'BOOKING_UPDATED':\r\n          callback({ type: 'BOOKING_UPDATED', booking: message.data });\r\n          break;\r\n        case 'BOOKING_CANCELLED':\r\n          callback({ type: 'BOOKING_CANCELLED', bookingId: message.bookingId });\r\n          break;\r\n      }\r\n    };\r\n\r\n    // Connect to WebSocket if not already connected\r\n    webSocketService.connect();\r\n    const unsubscribe = webSocketService.subscribe(handleMessage);\r\n\r\n    // Return cleanup function\r\n    return () => {\r\n      unsubscribe();\r\n      // Don't disconnect WebSocket here as it might be used by other components\r\n    };\r\n  }\r\n};\r\n\r\nexport default partnerService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}